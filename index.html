```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Viewer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      touch-action: none;
    }

    #pdf-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 100%;
      max-height: 100%;
      overflow: hidden;
      touch-action: pinch-zoom pan-x pan-y;
    }

    #pdf-canvas {
      border: 1px solid white;
      max-width: 90%;
      max-height: 90vh;
      width: auto;
      height: auto;
      transform-origin: center center;
      cursor: grab;
    }

    #pdf-canvas.dragging {
      cursor: grabbing;
    }

    #error-message {
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 80%;
    }

    @media (max-width: 768px) {
      #pdf-canvas {
        max-width: 95%;
        max-height: 95vh;
      }
    }
  </style>
</head>
<body>
  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
    <div id="error-message"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    // Replace with your PDF paths or use the sample PDF for testing
    const pdfUrls = [
      'page1.pdf',
      'page2.pdf',
      'page3.pdf'
      // For testing CORS: 'https://mozilla.github.io/pdf.js/web/compressed.tracemonkey.pdf'
    ];
    let currentPageIndex = 0;
    let pdfDoc = null;
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX, startY, startTranslateX, startTranslateY;

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('pdf-container');
    const errorMessage = document.getElementById('error-message');

    async function loadPDF(index) {
      try {
        const loadingTask = pdfjsLib.getDocument(pdfUrls[index]);
        pdfDoc = await loadingTask.promise;
        console.log(`Loaded PDF: ${pdfUrls[index]}`);
        errorMessage.style.display = 'none';
        canvas.style.border = '1px solid white';
        renderPage();
      } catch (error) {
        console.error('Error loading PDF:', error);
        canvas.style.border = '1px solid red';
        errorMessage.style.display = 'block';
        if (error.name === 'UnknownErrorException' && error.message.includes('CORS')) {
          errorMessage.textContent = `CORS error: Cannot load ${pdfUrls[index]}. Host PDFs on the same server or enable CORS on the PDF server.`;
        } else {
          errorMessage.textContent = `Failed to load ${pdfUrls[index]}. Check file path or server.`;
        }
      }
    }

    async function renderPage() {
      try {
        const page = await pdfDoc.getPage(1);
        const viewport = page.getViewport({ scale: 1 });

        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const scaleX = containerWidth / viewport.width * 0.9;
        const scaleY = containerHeight / viewport.height * 0.9;
        scale = Math.min(scaleX, scaleY);

        const scaledViewport = page.getViewport({ scale });
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;

        if (currentPageIndex === 1) {
          canvas.width = scaledViewport.width * 2;
        }

        translateX = (containerWidth - canvas.width) / 2;
        translateY = (containerHeight - canvas.height) / 2;
        updateTransform();

        if (currentPageIndex === 1) {
          const renderContext1 = {
            canvasContext: ctx,
            viewport: scaledViewport,
          };
          await page.render(renderContext1).promise;

          try {
            const page3Doc = await pdfjsLib.getDocument(pdfUrls[2]).promise;
            const page3 = await page3Doc.getPage(1);
            const renderContext2 = {
              canvasContext: ctx,
              viewport: scaledViewport,
              transform: [1, 0, 0, 1, scaledViewport.width, 0],
            };
            await page3.render(renderContext2).promise;
          } catch (error) {
            console.error('Error loading page3.pdf:', error);
            errorMessage.style.display = 'block';
            errorMessage.textContent = `Failed to load page3.pdf: ${error.message}`;
          }
        } else {
          const renderContext = {
            canvasContext: ctx,
            viewport: scaledViewport,
          };
          await page.render(renderContext).promise;
        }
      } catch (error) {
        console.error('Error rendering PDF:', error);
        canvas.style.border = '1px solid red';
        errorMessage.style.display = 'block';
        errorMessage.textContent = 'Failed to render PDF';
      }
    }

    function updateTransform() {
      canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    let lastDistance = null;
    function getDistance(touches) {
      if (touches.length < 2) return 0;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        isDragging = true;
        canvas.classList.add('dragging');
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        startTranslateX = translateX;
        startTranslateY = translateY;
      } else if (e.touches.length === 2) {
        lastDistance = getDistance(e.touches);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        translateX = startTranslateX + dx;
        translateY = startTranslateY + dy;
        updateTransform();
      } else if (e.touches.length === 2) {
        const distance = getDistance(e.touches);
        if (lastDistance) {
          const scaleChange = distance / lastDistance;
          scale *= scaleChange;
          scale = Math.max(0.5, Math.min(scale, 5));
          updateTransform();
        }
        lastDistance = distance;
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.changedTouches.length === 1 && isDragging) {
        isDragging = false;
        canvas.classList.remove('dragging');
      }
      lastDistance = null;
    });

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      canvas.classList.add('dragging');
      startX = e.clientX;
      startY = e.clientY;
      startTranslateX = translateX;
      startTranslateY = translateY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        translateX = startTranslateX + dx;
        translateY = startTranslateY + dy;
        updateTransform();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.classList.remove('dragging');
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomSpeed = 0.001;
      scale += e.deltaY * -zoomSpeed;
      scale = Math.max(0.5, Math.min(scale, 5));
      updateTransform();
    });

    canvas.addEventListener('click', () => {
      currentPageIndex = (currentPageIndex + 1) % 2;
      loadPDF(currentPageIndex);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') {
        currentPageIndex = (currentPageIndex + 1) % 2;
        loadPDF(currentPageIndex);
      } else if (e.key === 'ArrowLeft') {
        currentPageIndex = (currentPageIndex - 1 + 2) % 2;
        loadPDF(currentPageIndex);
      }
    });

    loadPDF(currentPageIndex);
  </script>
</body>
</html>
```