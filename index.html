<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Viewer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      touch-action: none; /* Prevent default touch behaviors */
    }

    #pdf-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 100%;
      max-height: 100%;
      overflow: hidden;
      touch-action: pinch-zoom pan-x pan-y; /* Allow pinch-zoom and panning */
    }

    #pdf-canvas {
      border: 1px solid white;
      max-width: 90%;
      max-height: 90vh;
      width: auto;
      height: auto;
      transform-origin: center center;
      cursor: grab;
    }

    #pdf-canvas.dragging {
      cursor: grabbing;
    }

    @media (max-width: 768px) {
      #pdf-canvas {
        max-width: 95%;
        max-height: 95vh;
      }
    }
  </style>
</head>
<body>
  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    // Initialize pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    const pdfUrls = ['page1.pdf', 'page2.pdf', 'page3.pdf'];
    let currentPageIndex = 0;
    let pdfDoc = null;
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX, startY;
    let startTranslateX, startTranslateY;

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('pdf-container');

    async function loadPDF(index) {
      try {
        const loadingTask = pdfjsLib.getDocument(pdfUrls[index]);
        pdfDoc = await loadingTask.promise;
        renderPage();
      } catch (error) {
        console.error('Error loading PDF:', error);
      }
    }

    async function renderPage() {
      const page = await pdfDoc.getPage(1);
      const viewport = page.getViewport({ scale: 1 });
      
      // Adjust scale to fit within container
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      const pdfWidth = viewport.width;
      const pdfHeight = viewport.height;
      const scaleX = containerWidth / pdfWidth * 0.9;
      const scaleY = containerHeight / pdfHeight * 0.9;
      scale = Math.min(scaleX, scaleY);
      
      const scaledViewport = page.getViewport({ scale });
      canvas.width = scaledViewport.width;
      canvas.height = scaledViewport.height;

      // For side-by-side display on pages 2 and 3
      if (currentPageIndex === 1) {
        canvas.width = scaledViewport.width * 2; // Double width for two pages
      }

      // Center the canvas
      translateX = (containerWidth - canvas.width) / 2;
      translateY = (containerHeight - canvas.height) / 2;
      updateTransform();

      // Render the page(s)
      if (currentPageIndex === 1) {
        // Render page2.pdf
        const renderContext1 = {
          canvasContext: ctx,
          viewport: scaledViewport,
        };
        await page.render(renderContext1).promise;

        // Render page3.pdf next to it
        const page3Doc = await pdfjsLib.getDocument(pdfUrls[2]).promise;
        const page3 = await page3Doc.getPage(1);
        const renderContext2 = {
          canvasContext: ctx,
          viewport: scaledViewport,
          transform: [1, 0, 0, 1, scaledViewport.width, 0], // Offset to the right
        };
        await page3.render(renderContext2).promise;
      } else {
        const renderContext = {
          canvasContext: ctx,
          viewport: scaledViewport,
        };
        await page.render(renderContext).promise;
      }
    }

    function updateTransform() {
      canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    // Zoom and Pan Handlers
    let lastDistance = null;

    function getDistance(touches) {
      if (touches.length < 2) return 0;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        isDragging = true;
        canvas.classList.add('dragging');
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        startTranslateX = translateX;
        startTranslateY = translateY;
      } else if (e.touches.length === 2) {
        lastDistance = getDistance(e.touches);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        translateX = startTranslateX + dx;
        translateY = startTranslateY + dy;
        updateTransform();
      } else if (e.touches.length === 2) {
        const distance = getDistance(e.touches);
        if (lastDistance) {
          const scaleChange = distance / lastDistance;
          scale *= scaleChange;
          scale = Math.max(0.5, Math.min(scale, 5)); // Limit zoom
          updateTransform();
        }
        lastDistance = distance;
      }
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.changedTouches.length === 1 && isDragging) {
        isDragging = false;
        canvas.classList.remove('dragging');
      }
      lastDistance = null;
    });

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      canvas.classList.add('dragging');
      startX = e.clientX;
      startY = e.clientY;
      startTranslateX = translateX;
      startTranslateY = translateY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        translateX = startTranslateX + dx;
        translateY = startTranslateY + dy;
        updateTransform();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.classList.remove('dragging');
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomSpeed = 0.001;
      scale += e.deltaY * -zoomSpeed;
      scale = Math.max(0.5, Math.min(scale, 5)); // Limit zoom
      updateTransform();
    });

    // Page Navigation
    canvas.addEventListener('click', () => {
      currentPageIndex = (currentPageIndex + 1) % 2; // Toggle between page1 and page2+3
      loadPDF(currentPageIndex);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') {
        currentPageIndex = (currentPageIndex + 1) % 2;
        loadPDF(currentPageIndex);
      } else if (e.key === 'ArrowLeft') {
        currentPageIndex = (currentPageIndex - 1 + 2) % 2;
        loadPDF(currentPageIndex);
      }
    });

    // Initial Load
    loadPDF(currentPageIndex);
  </script>
</body>
</html>