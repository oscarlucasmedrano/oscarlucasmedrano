<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Oscar-Lucas Medrano</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';
  </script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background: black;
      overflow: hidden;
      touch-action: none;
    }

    #viewport {
      width: 100%;
      height: 100%;
      overflow: auto;
      background: black;
      position: relative;
      touch-action: pan-x pan-y;
    }

    #pdf-container {
      position: absolute;
      display: flex;
      flex-direction: row;
      gap: 10px;
      transform: scale(1);
      transform-origin: center center;
      transition: transform 0.05s linear;
    }

    canvas {
      display: block;
      background: black;
      border: 1px solid white;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="pdf-container"></div>
  </div>

  <script>
    const totalPages = 32;
    const pdfFiles = Array.from({ length: totalPages }, (_, i) => `page${i + 1}.pdf`);
    let currentIndex = 0;
    let basePdfScale = 1.5;
    let viewScale = 1;
    const fixedCanvasHeight = 1100;

    const container = document.getElementById("pdf-container");
    const viewport = document.getElementById("viewport");

    async function loadCanvas(pdfUrl) {
      const pdf = await pdfjsLib.getDocument(pdfUrl).promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({ scale: 1 });
      const aspectRatio = viewport.width / viewport.height;

      const canvas = document.createElement("canvas");
      canvas.height = fixedCanvasHeight;
      canvas.width = canvas.height * aspectRatio;

      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const scale = canvas.height / viewport.height;
      const scaledViewport = page.getViewport({ scale });
      await page.render({ canvasContext: ctx, viewport: scaledViewport, background: 'black' }).promise;

      return canvas;
    }

    function applyZoom() {
      container.style.transform = `scale(${viewScale})`;
    }

    function centerSpread(canvases) {
      const totalWidth = canvases.reduce((sum, c) => sum + c.width, 0) + (canvases.length - 1) * 10;
      const maxHeight = Math.max(...canvases.map(c => c.height));
      const scaleX = window.innerWidth * 0.95 / totalWidth;
      const scaleY = window.innerHeight * 0.95 / maxHeight;
      viewScale = Math.min(scaleX, scaleY, 1);
      applyZoom();

      const offsetLeft = (window.innerWidth - totalWidth * viewScale) / 2;
      const offsetTop = (window.innerHeight - maxHeight * viewScale) / 2;
      container.style.left = `${offsetLeft}px`;
      container.style.top = `${offsetTop}px`;
    }

    function scrollToCenter() {
      const rect = container.getBoundingClientRect();
      const scrollX = container.offsetLeft + container.offsetWidth / 2 - window.innerWidth / 2;
      const scrollY = container.offsetTop + container.offsetHeight / 2 - window.innerHeight / 2;
      viewport.scrollTo({ top: scrollY, left: scrollX, behavior: 'instant' });
    }

    async function renderSpread(index) {
      container.innerHTML = '';
      let canvases = [];

      if (index === 0) {
        canvases = [await loadCanvas(pdfFiles[0])];
      } else {
        const left = await loadCanvas(pdfFiles[index]);
        const rightIndex = index + 1;
        canvases.push(left);
        if (rightIndex < pdfFiles.length) {
          const right = await loadCanvas(pdfFiles[rightIndex]);
          canvases.push(right);
        }
      }

      canvases.forEach(canvas => container.appendChild(canvas));
      centerSpread(canvases);
      requestAnimationFrame(() => scrollToCenter());
    }

    function showNext() {
      currentIndex = currentIndex === 0 ? 1 : currentIndex + 2;
      if (currentIndex >= pdfFiles.length) currentIndex = pdfFiles.length - 1;
      renderSpread(currentIndex);
    }

    function showPrev() {
      currentIndex = currentIndex <= 1 ? 0 : currentIndex - 2;
      renderSpread(currentIndex);
    }

    // Zoom via trackpad/mouse
    viewport.addEventListener("wheel", (e) => {
      if (e.ctrlKey || Math.abs(e.deltaY) < 50) {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.95 : 1.05;
        viewScale = Math.max(0.3, Math.min(viewScale * factor, 5));
        const rect = container.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;
        container.style.transformOrigin = `${offsetX}px ${offsetY}px`;
        applyZoom();
      }
    }, { passive: false });

    // Pinch to zoom on mobile
    let lastDist = null;
    viewport.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        const [t1, t2] = e.touches;
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        const dist = Math.hypot(dx, dy);
        if (lastDist) {
          const factor = dist > lastDist ? 1.02 : 0.98;
          viewScale = Math.max(0.3, Math.min(viewScale * factor, 5));
          const midX = (t1.clientX + t2.clientX) / 2;
          const midY = (t1.clientY + t2.clientY) / 2;
          const rect = container.getBoundingClientRect();
          const offsetX = midX - rect.left;
          const offsetY = midY - rect.top;
          container.style.transformOrigin = `${offsetX}px ${offsetY}px`;
          applyZoom();
        }
        lastDist = dist;
      }
    }, { passive: false });
    viewport.addEventListener("touchend", () => lastDist = null);

    // Navigation
    document.addEventListener("keydown", e => {
      if (e.key === "ArrowRight") showNext();
      if (e.key === "ArrowLeft") showPrev();
    });
    viewport.addEventListener("click", e => {
      if (e.clientX > window.innerWidth / 2) showNext();
      else showPrev();
    });

    window.addEventListener("resize", () => renderSpread(currentIndex));

    renderSpread(currentIndex);
  </script>
</body>
</html>
